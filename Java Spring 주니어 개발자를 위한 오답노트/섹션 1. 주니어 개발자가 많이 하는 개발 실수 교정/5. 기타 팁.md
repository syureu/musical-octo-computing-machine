# 오해

## a. 500 response

500 에러는 사실상 장애 선언이다.

의도된 로직이거나 이미 알려진 이유로 API가 실패한 경우 이에 대한 원인 혹은 오류코드를 제공해야 한다

> 500 에러를 의도된 리스폰스로 만들지 말라는 생각과 합치

## b. 개발의 목적

좋은 프로그램

1. <b>돌아가야한다</b>
2. 유지 보수가 가능해야한다

간혹 긴 기간 설계에만 심취한 경우가 있다. 개발자라는 직업이름자체도 개발하는 사람인데 당연히 주 목적은 개발을 해야됨.

요구사항에 따른 분석과 설계 구현을 진행해야되는데 구현까지 되지 않았다면 그것은 개발되지 않은것과 같음

오버 엔지니어링으로 인한 개발 지연을 염두하라

## c. 디자인 패턴에 매몰되지 마세요.

디자인 패턴은 시스템을 위한 것이지
시스템이 디자인 패턴을 위한 것이 되면 안됨

특정 디자인 패턴을 이용하고 있으므로 개발이 어려울 것 같다 라는 말은
개발의 목적을 잊고 패넡에 매몰되어버린 것임

## d. 프로그래머 vs 소프트웨어 엔지니어

"구글 엔지니어는 이렇게 일한다" 책에 나온 내용인데

* We see three critical difference between programming and software engineering: time, scale, and the trade-off at play.

시간과 규모, 트레이드 오프를 고려할줄 아냐 모르냐가 다르다는 건데
그냥 주어진 요구사항을 만들어 낼줄 알면 프로그래밍이지만, 이를 주어진 상황 조건에 맞게 만들어 낼줄 안다면 (ex : 그저 한달정도 임시로 동작해야될 코드엔 그만큼의 가벼운 공수를, 몇 년간 유지되어야 되는 시스템엔 심오한 설계를) 그걸 엔지니어링이라고 말한다는 것

# OOP

## a. OOP

### OOP

Object oriented programming이므로 객체 지향 프로그래밍이지 클래스 지향 프로그래밍이 아님

클래스는 그저 객체를 다루기 위한 도구 중 하나

그러므로 객체에 집중한다면 좀 더 좋은 결과를 만들 수 있을 것

### TDD / DDD / FP

tdd나 ddd, funtional programming을 하는 이유는
잘 설계된 OOP 결과물을 만들기 위한것이지, tdd, ddd, fp 그 자체를 하기 위한 것은 아님

oop를 잘 하기위해 이것들을 한번씩 맛보는건 좋을 수 있음

## b. DDD

### Domain Driven Design

Domain이라는 객체 모델을 어떻게하면 잘 정의할 수 있을까? 라는 이야기임

마지막 d가 development가 아니고 design인것에 주목하면 개발방법론 보다 설계에 가깝다는 느낌

## c. vs 절차지향

OOP는 정답이 아니다

객체지향보다 절차지향이 작성도 빠르고 읽히기도 빠르다
객체지향이 없던 시절엔 절차지향으로도 잘만 좋은 코드 만들었다
어떤 것이 우위의 개념이 아님

## d. 역할극

역할, 책임, 협력

OOP를 관통하는 키워드인데 결국 각각의 객체들이 가진 역할과 책임에 따른 일을 수행하며 각 객체들이 서로 협력하는것을 통해 객체 지향 프로그래밍이 되는 것이고 역할극에 비춰 볼 수 있음

## e. 객체지향 생활 체조 9가지 원칙

마틴 파울러, 소트웍스 앤솔러지 소프트웨어 기술과 혁신에 관한 에세이

1. 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다
2. else 예약어를 쓰지 않는다
3. 모든 원시값과 문자열을 포장한다
4. 한 줄에 점을 하나만 찍는다
5. 줄여쓰지 않는다 (축약 금지)
6. 모든 엔티티를 작게 유지한다
7. 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다
8. 일급 컬렉션을 쓴다
9. getter / setter / property 를 쓰지 않는다

# 습관

## a. apache utils

CollectionUtils / StringUtils / ObjectUtils

> 우린 이미 적용하고 있음

## b. 상속

상속을 지양하고 Composition 을 지향할 것

컴포지션은

공통 기능을 별도의 컴포넌트로 분리하고
그 컴포넌트를 멤버 변수로 갖고 기능을 이용하게 하는 것

## c. 테스트

테스트 하기 쉽다면 좋은 설계일 확률이 높다

코드를 짜면서 "이 코드가 테스트 하기 쉬운가?" 와 같은걸 많이 생각해보고 그렇지 않다면 "어떻게 테스트 하기 쉽게 만들까?" 와 같은 개선사항에 대해서 고민해봐도 좋음

꼭 TDD를 하지 않더라도 이러한 테스트에 대한 고려가 녹아든다면 좋은 설계가 되기 좋음

## d. 블락

한 메서드에 블럭이 여러개로 나뉜다면

ex

```java
public void temp() {
    a;
    b;

    c;
    d;

    e;
    f;
}
```

이렇게 개행을 나눈 것을 메소드로 쪼개는 것을 고려할 것

개행이 나뉘었다는 것은 논리적으로 다른 단계임을 의미함

단순 가독성을 위한 코드 분리여도 괜찮음 (해당 코드 블럭이 어떤 코드인지 메서드 이름을 통해서 나타내기도 좋음 -> 주석을 쓰지 않아도 된다는 의미)

## e. Tab in tab in tab

9계명에 있던 내용인데 인덴트가 두 번 이상 들어간다면 메소드 위의 블럭과 같이 봐서 (이건 정말 물리적인 스코프니까) 메소드 분할을 할 것
